# Graph-Based Network Evolution

Graph-based neural networks with topology mutations for evolving network architectures.

Contains Node class with three distinct roles: Input nodes forward signals non-parametrically (count matches input dimension, no incoming connections, no parameters), Hidden nodes are mutable and parametric (maximum 3 incoming connections with frozen random weights initialized at creation, no biases, apply standardization via standardize(weights·in_nodes'outputs) using Welford running statistics), Output nodes inherit hidden node properties (count matches output dimension, never pruned during evolution). Node attributes include mutable_uid (position-dependent identifier that changes when topology mutates), immutable_uid (permanent lifetime tracking ID for debugging and analysis), in_nodes list (nodes feeding into this node), out_nodes list (nodes this node feeds into). NodeList class provides list-like container for nodes with special indexing. Net class manages the graph structure with start() method initializing minimal topology (direct input→output connections only), mutate_grow_node() adds new hidden node with random connections, mutate_prune_node() removes least-connected hidden nodes (never prunes outputs), mutate_grow_connection() creates new edge between existing nodes respecting the ≤3 incoming connection limit, mutate_prune_connection() removes random edges. Mutation probabilities controlled by p_grow_node, p_prune_node, p_grow_connection, p_prune_connection hyperparameters (typically 0.1-0.3 each). Networks can contain cycles enabling graph-based recurrence through feedback loops. Forward computation uses topological ordering when acyclic or multiple forward passes when cyclic (configurable via max_passes parameter). Connection weights are frozen random values (not trainable), with network behavior evolving through topology changes rather than weight updates. Used by main.py's DynamicNetPopulation for evolutionary optimization in conjunction with batched GPU computation infrastructure. Networks start with minimal structure (input and output nodes only, direct connections) then progressively grow complex architectures through accumulated mutations over generations. Fitness-driven selection pressure guides evolution toward effective topologies. get_state_dict() and load_state_dict() support checkpointing entire network graphs including all nodes, connections, UIDs, and standardization states. Compatible only with genetic algorithms (GA) due to non-differentiable topology changes, not compatible with gradient-based methods or parameter-averaging algorithms like ES/CMA-ES.
